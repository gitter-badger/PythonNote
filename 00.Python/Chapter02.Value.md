# 2 数值
## 2.1 数值类型及其表示
Python数值类型优势：  
相比C/C++避免了数值范围限制。
### 2.1.1 数字型（整、浮、复、布）
1. 整数（整形数int）  
    概念：所有非小数的数；

计算机字面值表示方式：
十进制表示：直接表示。（-5，0，99999）
二进制表示：0b + 0~1。（0b111，0b101）
八进制表示：0o + 0~7。（0o7，0o10，0o17）
十六2  	数值
2.1  	数值类型及其表示
python数值类型优势：
相比C/C++避免了数值范围限制。
2.1.1  	数字型（整、浮、复、布）
	整数（整形数int）
概念：所有非小数的数；

计算机字面值表示方式：
十进制表示：直接表示。（-5，0，99999）
二进制表示：0b + 0~1。（0b111，0b101）
八进制表示：0o + 0~7。（0o7，0o10，0o17）
十六进制表示：0x + 0~9，A~F。（0x11，0xff，0xFF）大小写无关

注：
Python输出的数值均以十进制表达，打印和输出其他进制见本章末（）
示例：
>>> 0b111
7
>>> 0o17
15
>>> 0xff
255
	浮点数（浮点型数float）
字面值：
小数形式：3.14		3.1		3.		0.14		.14
科学计数法：小数 + e/E + 正负号 + 指数
>>> 3.14e-2
0.0314
>>> 3.14e8
314000000.0
注意：浮点型数无double类型，不同于C/C++
	复数complex
字面值：1j	（2j）	1+1J	3-4J	(-100+100J)
特点：Python数据类型可以表示复数，不同于C/C++
构成：实部(real)和虚部(image)
>>> -1+9j
(-1+9j)
>>> 1+9j
(1+9j)
	布尔值
字面值：True  False
注意：布尔值非零既真；Ture == 1，表示数值相等，可加减
>>> bool("123")
Ture
>>> bool( 2 )  # 非零既真
Ture

>>> True
True
>>> 1
1
>>> True == 1  
True
>>> True is 1
False
>>> id(True)  #True也在小对象池内，运行结束对象不销毁
262398640
>>> id(1)     #1在小对象池内，运行结束对象不销毁(多次运行此句id无变化)
262617344
>>> True == 6
False
>>> True + 1  #可加减
2
2.1.2  	空值None对象
概念：None是一个表示不存在的特殊对象
作用：用来占位；用来变量绑定
>>> a=None
>>> help('__main__')
Help on module __main__:

NAME
    __main__

DATA
    __annotations__ = {}
    a = None

FILE
    (built-in)
2.2  	数值相关函数
2.2.1  	数值对象的构造（创建）函数
	int()函数
1) 将其他类型数值转换为十进制整数
int([x]) 将数字统一转换为整数
选项：
[x]    缺省参数默认为零, x可以为整数(包括其他进制)、浮点数、布尔数，但不可为复数
示例（交互模式下）：
int()    #0，缺省参数，int()==0
int(3)   #3，整数
int(0b11)  #3，二进制整数
int(3.14)  #3，浮点数
int(bool())  #0，布尔值
int(bool(666))  #1，布尔值
2) 将字符串数值转换为十进制整数
int("obj"[, ase]) 将进制为ase的整型数obj字符串，统一转换为十进制的数字
选项：
obj     必须为表示“整型数的字符串”，不可为浮点数、复数、布尔数(True/False)
[ase]   表示该字符串数代表的进制数，缺省参数为10
	示例：
int("4")       #4
int("4", 10)   #4
int("0b100")   #报错，触发ValueError异常，因为ase默认参数是10
int("0b100",2) #4
int("100",2)   #4
int("100")     #100，缺省参数为10，int("obj") == int("obj",10)
int("100",10)  #100

	错误示例：
int("3.14")  #不是整型数，报错
int(3.14)    #3，正确
int(100, 2)   #100不是字符串，报错
int("100", 2)  #4，正确
	float()
float([x])    #将数字(除复数外)统一转换为浮点数
x        可以为数值(整数，浮点数，布尔值)，以及表示整数和浮点数的字符串
float(3)  #3.0
float("3")  #3.0
float(3.14)  #3.14
float("3.14")  #3.14
float(False)  #0.0
float("False")  #报错
	complex()
complex(a,b)	#a,b代表实部和虚部的值
	bool()
bool(x) 		#不为零即为真
返回：True 或 False，可直接参与数值运算，前者为1，后者为0。因为python中True==1。
bool(x)返回假值的情况：x为一切空的东西，如下
#无参数
None    #空值
False   #布尔假值
0.0     
0j      
''      #空字符串
()      #空
[]      
{}      
set()   #空集合
…
2.2.2  	进制与编码互相转换的函数
字符串编码(值)的转换函数：
ord(c)		返回一个字符的Unicode值
chr(i)		返回编码值对应的字符
整数转换进制字符串的函数：
hex(i)		转换为十六进制的字符串
oct(i)		转换为八进制的字符串
bin(i)		转换为二进制的字符串
2.2.3  	常用运算函数
	abs()返回给定参数的绝对值
abs(数值)
>>> abs(-9)
9
	pow()指数计算
计算x的y次方
1) 内置的 pow() 方法
pow(x, y[, z])     #pow(x,y,z) 结果等效于pow(x,y) %z
>>> pow(2,3)
8
>>> pow(2,3,3)
2
2) math模块 pow() 方法:
import math
math.pow(x, y)
>>> import math
>>> math.pow(2,3)
8.0
	round()四舍五入
对数值进行四舍五入
round(number[, ndigits])
number    数值
ndigits   小数向右取整的位数，负数表示向左取整
>>> round(3.66,1)
3.7
>>> '%.1f'%3.66  # "%.1f"%num相当于round(num,1)
'3.7'
>>> round(1234,-1)
1230
>>> round(1234,-2)
1200

2.3  	运算及运算符
2.3.1  	算术运算符
所有的运算都遵循数学法则，如5/2=2.5。
算术运算符包括：
+	 加法
-	 减法
*	 乘法
/	 除法后都变成浮点数，如4/2=2.0。注意python2中不遵循该规则
//	 地板除（除的结果去掉小数部分向下取整）,如5//2=2，3.25//1.5=2.0
%	 取余（也叫取模）
**	 幂运算
注：
1）运算中有混合类型自动升级。如1+2.2=3.2
2）在表达式的运算过程中，相比C/C++不损失精度，如1/3*3=1.0 
运算符优先级：
()    #括号分组子表达式，用“()”可以将表达式分组，“()”内的表达式先进行计算
**    #幂运算
*  /  //  %
+  -
示例:
1 + 3 * 3 ** 2 + 4 // 2
1 + 3 * 9 + 4 // 2
1 + 27 + 4 // 2
1 + 27 + 2
28 + 2
30

2.3.2  	复合赋值运算符
y += x     ==>     y = y + x
…
2.3.3  	比较运算符
<
<=
>
>=
==
!=
结果返回：布尔类型的值True  False
运算规则：多个比较运算符的运算规则，从左到右
例如：
>>> 3>2<3
True

了解：python2中的内建函数cmp，python3中该函数已被废弃(奥卡提姆剃须刀)
cmp(x,y)  #比较x和y的大小，x<y返回-1，x=y返回0，x>y返回1
2.3.4  	位运算符
（此内容初学仅作了解）
运算符	描述	实例
&	按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	(a & b) 输出结果 12 ，二进制解释： 0000 1100
|	按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	(a | b) 输出结果 61 ，二进制解释： 0011 1101
^	按位异或运算符：当两对应的二进位相异时，结果为1	(a ^ b) 输出结果 49 ，二进制解释： 0011 0001
~	按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1	(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。
<<	左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。	a << 2 输出结果 240 ，二进制解释： 1111 0000
>>	右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数	a >> 2 输出结果 15 ，二进制解释： 0000 1111
以下实例演示了Python所有位运算符的操作：
示例：
a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 
c = a & b;        # 12 = 0000 1100     &找都为真的。相加取2为1，其余为0
c = a | b;        # 61 = 0011 1101     |找都为假的。相加取0为0，其余为1
c = a ^ b;        # 49 = 0011 0001     ^找两两不同的，为1。相减，取绝对值
c = ~a;           # -61 = 1100 0011    ~每一位取反。相当于-a-1
c = a << 2;       # 240 = 1111 0000   <<左移两位，补零
c = a >> 2;       # 15 = 0000 1111    >>右移两位，补零
2.3.5  	运算误差问题汇总
	1）浮点数运算误差
问题引入：出现误差。
>>> 3.14 - int(3)
0.14000000000000012
证明：
>>> int(3.14)==3    # 构造函数int()会让得到的数值产生误差吗？不会
True
>>> 3.14 - 3
0.14000000000000012
>>> 3.14 - 3.0
0.14000000000000012
>>> 3.14 - 3.00
0.14000000000000012
误差本质其实是浮点数值的运算，浮点数运算可能会出现误差
>>> 1/3
0.3333333333333333       #得到的是一个确定的数，非无理数

>>> 1/3 == 0.3333333333333333    #保留16位，两者竟然相等！奇怪的机制
True

>>> 7/3 - 2
0.3333333333333335    #最后一位不遵循四舍五入。
>>> 7/3
2.3333333333333335

>>> 3.25 % 1.5
0.25
>>> 3.26 % 1.5
0.2599999999999998    #结果应该为0.26，但损失了精度
小思索：计算机还存在误差，这些因素究竟为何？我们的计算还无法进行抽象概念的计算？如何解决？计算的误差，创造真正的机器智能，或是探索宇宙本质？
	2）round()函数的误差
问题引入：round结果应该是3.65≈3.7，但返回3.6
>>> round(3.65,1)
3.6
>>> '%.1f'%3.65
'3.6'
若想进一步了解，help(round)可以查看四舍五入运算的机制


注：
Python输出的数值均以十进制表达，打印和输出其他进制见本章末（）
示例：
>>> 0b111
7
>>> 0o17
15
>>> 0xff
255
- 浮点数（浮点型数float）
字面值：
小数形式：3.14		3.1		3.		0.14		.14
科学计数法：小数 + e/E + 正负号 + 指数
>>> 3.14e-2
0.0314
>>> 3.14e8
314000000.0
注意：浮点型数无double类型，不同于C/C++
- 复数complex
字面值：1j	（2j）	1+1J	3-4J	(-100+100J)
特点：Python数据类型可以表示复数，不同于C/C++
构成：实部(real)和虚部(image)
>>> -1+9j
(-1+9j)
>>> 1+9j
(1+9j)
- 布尔值
字面值：True  False
注意：布尔值非零既真；Ture == 1，表示数值相等，可加减
>>> bool("123")
Ture
>>> bool( 2 )  # 非零既真
Ture

>>> True
True
>>> 1
1
>>> True == 1  
True
>>> True is 1
False
>>> id(True)  #True也在小对象池内，运行结束对象不销毁
262398640
>>> id(1)     #1在小对象池内，运行结束对象不销毁(多次运行此句id无变化)
262617344
>>> True == 6
False
>>> True + 1  #可加减
2
2.1.2 空值None对象
概念：None是一个表示不存在的特殊对象
作用：用来占位；用来变量绑定
>>> a=None
>>> help('__main__')
Help on module __main__:

NAME
    __main__

DATA
    __annotations__ = {}
    a = None

FILE
    (built-in)
2.2 数值相关函数
2.2.1 数值对象的构造（创建）函数
- int()函数
1) 将其他类型数值转换为十进制整数
int([x]) 将数字统一转换为整数
选项：
[x]    缺省参数默认为零, x可以为整数(包括其他进制)、浮点数、布尔数，但不可为复数
示例（交互模式下）：
int()    #0，缺省参数，int()==0
int(3)   #3，整数
int(0b11)  #3，二进制整数
int(3.14)  #3，浮点数
int(bool())  #0，布尔值
int(bool(666))  #1，布尔值
2) 将字符串数值转换为十进制整数
int("obj"[, ase]) 将进制为ase的整型数obj字符串，统一转换为十进制的数字
选项：
obj     必须为表示“整型数的字符串”，不可为浮点数、复数、布尔数(True/False)
[ase]   表示该字符串数代表的进制数，缺省参数为10
	示例：
int("4")       #4
int("4", 10)   #4
int("0b100")   #报错，触发ValueError异常，因为ase默认参数是10
int("0b100",2) #4
int("100",2)   #4
int("100")     #100，缺省参数为10，int("obj") == int("obj",10)
int("100",10)  #100

	错误示例：
int("3.14")  #不是整型数，报错
int(3.14)    #3，正确
int(100, 2)   #100不是字符串，报错
int("100", 2)  #4，正确
- float()
float([x])    #将数字(除复数外)统一转换为浮点数
x        可以为数值(整数，浮点数，布尔值)，以及表示整数和浮点数的字符串
float(3)  #3.0
float("3")  #3.0
float(3.14)  #3.14
float("3.14")  #3.14
float(False)  #0.0
float("False")  #报错
- complex()
complex(a,b)	#a,b代表实部和虚部的值
- bool()
bool(x) 		#不为零即为真
返回：True 或 False，可直接参与数值运算，前者为1，后者为0。因为python中True==1。
bool(x)返回假值的情况：x为一切空的东西，如下
#无参数
None    #空值
False   #布尔假值
0.0     
0j      
''      #空字符串
()      #空
[]      
{}      
set()   #空集合
…
2.2.2 进制与编码互相转换的函数
字符串编码(值)的转换函数：
ord(c)		返回一个字符的Unicode值
chr(i)		返回编码值对应的字符
整数转换进制字符串的函数：
hex(i)		转换为十六进制的字符串
oct(i)		转换为八进制的字符串
bin(i)		转换为二进制的字符串
2.2.3 常用运算函数
- abs()返回给定参数的绝对值
abs(数值)
>>> abs(-9)
9
- pow()指数计算
计算x的y次方
1) 内置的 pow() 方法
pow(x, y[, z])     #pow(x,y,z) 结果等效于pow(x,y) %z
>>> pow(2,3)
8
>>> pow(2,3,3)
2
2) math模块 pow() 方法:
import math
math.pow(x, y)
>>> import math
>>> math.pow(2,3)
8.0
- round()四舍五入
对数值进行四舍五入
round(number[, ndigits])
number    数值
ndigits   小数向右取整的位数，负数表示向左取整
>>> round(3.66,1)
3.7
>>> '%.1f'%3.66  # "%.1f"%num相当于round(num,1)
'3.7'
>>> round(1234,-1)
1230
>>> round(1234,-2)
1200

2.3 运算及运算符
2.3.1 算术运算符
所有的运算都遵循数学法则，如5/2=2.5。
算术运算符包括：
+	 加法
-	 减法
*	 乘法
/	 除法后都变成浮点数，如4/2=2.0。注意python2中不遵循该规则
//	 地板除（除的结果去掉小数部分向下取整）,如5//2=2，3.25//1.5=2.0
%	 取余（也叫取模）
**	 幂运算
注：
1）运算中有混合类型自动升级。如1+2.2=3.2
2）在表达式的运算过程中，相比C/C++不损失精度，如1/3*3=1.0 
运算符优先级：
()    #括号分组子表达式，用“()”可以将表达式分组，“()”内的表达式先进行计算
**    #幂运算
*  /  //  %
+  -
示例:
1 + 3 * 3 ** 2 + 4 // 2
1 + 3 * 9 + 4 // 2
1 + 27 + 4 // 2
1 + 27 + 2
28 + 2
30

2.3.2 复合赋值运算符
y += x     ==>     y = y + x
…
2.3.3 比较运算符
<
<=
>
>=
==
!=
结果返回：布尔类型的值True  False
运算规则：多个比较运算符的运算规则，从左到右
例如：
>>> 3>2<3
True

了解：python2中的内建函数cmp，python3中该函数已被废弃(奥卡提姆剃须刀)
cmp(x,y)  #比较x和y的大小，x<y返回-1，x=y返回0，x>y返回1
2.3.4 位运算符
（此内容初学仅作了解）
运算符	描述	实例
&	按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0	(a & b) 输出结果 12 ，二进制解释： 0000 1100
|	按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。	(a | b) 输出结果 61 ，二进制解释： 0011 1101
^	按位异或运算符：当两对应的二进位相异时，结果为1	(a ^ b) 输出结果 49 ，二进制解释： 0011 0001
~	按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1	(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。
<<	左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。	a << 2 输出结果 240 ，二进制解释： 1111 0000
>>	右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数	a >> 2 输出结果 15 ，二进制解释： 0000 1111
以下实例演示了Python所有位运算符的操作：
示例：
a = 60            # 60 = 0011 1100 
b = 13            # 13 = 0000 1101 
c = a & b;        # 12 = 0000 1100     &找都为真的。相加取2为1，其余为0
c = a | b;        # 61 = 0011 1101     |找都为假的。相加取0为0，其余为1
c = a ^ b;        # 49 = 0011 0001     ^找两两不同的，为1。相减，取绝对值
c = ~a;           # -61 = 1100 0011    ~每一位取反。相当于-a-1
c = a << 2;       # 240 = 1111 0000   <<左移两位，补零
c = a >> 2;       # 15 = 0000 1111    >>右移两位，补零
2.3.5 运算误差问题汇总
- 1）浮点数运算误差
问题引入：出现误差。
>>> 3.14 - int(3)
0.14000000000000012
证明：
>>> int(3.14)==3    # 构造函数int()会让得到的数值产生误差吗？不会
True
>>> 3.14 - 3
0.14000000000000012
>>> 3.14 - 3.0
0.14000000000000012
>>> 3.14 - 3.00
0.14000000000000012
误差本质其实是浮点数值的运算，浮点数运算可能会出现误差
>>> 1/3
0.3333333333333333       #得到的是一个确定的数，非无理数

>>> 1/3 == 0.3333333333333333    #保留16位，两者竟然相等！奇怪的机制
True

>>> 7/3 - 2
0.3333333333333335    #最后一位不遵循四舍五入。
>>> 7/3
2.3333333333333335

>>> 3.25 % 1.5
0.25
>>> 3.26 % 1.5
0.2599999999999998    #结果应该为0.26，但损失了精度
小思索：计算机还存在误差，这些因素究竟为何？我们的计算还无法进行抽象概念的计算？如何解决？计算的误差，创造真正的机器智能，或是探索宇宙本质？
- 2）round()函数的误差
问题引入：round结果应该是3.65≈3.7，但返回3.6
>>> round(3.65,1)
3.6
>>> '%.1f'%3.65
'3.6'
若想进一步了解，help(round)可以查看四舍五入运算的机制
